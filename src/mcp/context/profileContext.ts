/**
 * Facade for profile operations
 */
import {
  ProfileRepository,
  ProfileEmbeddingService,
  ProfileTagService,
  ProfileSearchService,
} from '@/services/profiles';

import type { Profile } from '@/models/profile';
import logger from '@/utils/logger';

interface NoteWithSimilarity {
  id: string;
  title: string;
  content: string;
  tags?: string[] | null;
  embedding?: number[] | null;
  similarity?: number;
  createdAt: Date;
  updatedAt: Date;
}

interface NoteContext {
  searchNotesWithEmbedding: (embedding: number[], limit?: number) => Promise<NoteWithSimilarity[]>;
  searchNotes: (options: { query?: string; tags?: string[]; limit?: number; includeContent?: boolean }) => Promise<NoteWithSimilarity[]>;
}

/**
 * Manages a user profile with vector embeddings and tag generation
 * Acts as a facade over specialized profile services
 */
export class ProfileContext {
  private repository: ProfileRepository;
  private embeddingService: ProfileEmbeddingService;
  private tagService: ProfileTagService;
  private searchService: ProfileSearchService;

  constructor(apiKey?: string) {
    this.repository = new ProfileRepository();
    this.embeddingService = new ProfileEmbeddingService(apiKey);
    this.tagService = new ProfileTagService();
    this.searchService = new ProfileSearchService();
  }

  /**
   * Retrieve the user profile
   * @returns The user profile or undefined if not found
   */
  async getProfile(): Promise<Profile | undefined> {
    return this.repository.getProfile();
  }

  /**
   * Create or update the user profile with automatic tag and embedding generation
   * @param profileData The profile data without system fields
   * @returns The ID of the created or updated profile
   */
  async saveProfile(
    profileData: Omit<Profile, 'id' | 'createdAt' | 'updatedAt' | 'embedding' | 'tags'>,
  ): Promise<string> {
    try {
      // Generate profile text for embedding and tagging
      const profileText = this.embeddingService.getProfileTextForEmbedding(profileData);

      // Generate embedding and tags
      const embedding = await this.embeddingService.generateEmbedding(profileText);
      const tags = await this.tagService.generateProfileTags(profileText);

      if (!embedding || !tags) {
        throw new Error('Failed to generate profile embedding or tags');
      }

      // Check if profile exists
      const existingProfile = await this.repository.getProfile();

      if (existingProfile) {
        // Update existing profile
        const success = await this.repository.updateProfile(existingProfile.id, {
          ...profileData,
          embedding,
          tags,
        });

        if (!success) {
          throw new Error('Failed to update profile');
        }

        return existingProfile.id;
      } else {
        // Create new profile
        // Create profile with proper typing for experiences field
        const newProfile: Profile = {
          ...profileData,
          embedding,
          tags,
          id: '', // Will be generated by repository
          createdAt: new Date(),
          updatedAt: new Date(),
          // Don't spread the experiences to avoid type conflicts
          experiences: profileData.experiences,
        };

        return this.repository.insertProfile(newProfile);
      }
    } catch (error) {
      logger.error(`Failed to save profile: ${error instanceof Error ? error.message : String(error)}`);
      throw error;
    }
  }

  /**
   * Update partial profile data with automatic embedding regeneration when needed
   * @param profileData The partial profile data to update
   */
  async updateProfile(profileData: Partial<Profile>): Promise<void> {
    const existingProfile = await this.repository.getProfile();

    if (!existingProfile) {
      throw new Error('No profile exists to update');
    }

    // If profile content is being updated, regenerate the embedding
    if (this.embeddingService.shouldRegenerateEmbedding(profileData)) {
      const updatedProfile = { ...existingProfile, ...profileData };
      const profileText = this.embeddingService.getProfileTextForEmbedding(updatedProfile);
      const embedding = await this.embeddingService.generateEmbedding(profileText);

      if (embedding?.length) {
        profileData.embedding = embedding;
      }
    }

    // Update the profile with all changes
    const success = await this.repository.updateProfile(existingProfile.id, profileData);
    
    if (!success) {
      throw new Error('Failed to update profile');
    }
  }

  /**
   * Generate or update embeddings for the profile
   * @returns Status of the update operation
   */
  async generateEmbeddingForProfile(): Promise<{ updated: boolean }> {
    return this.embeddingService.generateEmbeddingForProfile();
  }

  /**
   * Update or generate tags for an existing profile
   * @param forceRegenerate Whether to force regeneration of tags
   * @returns The updated tags or null if operation failed
   */
  async updateProfileTags(forceRegenerate = false): Promise<string[] | null> {
    return this.tagService.updateProfileTags(forceRegenerate);
  }

  /**
   * Find notes related to the profile using tags or embeddings
   * @param noteContext The NoteContext for searching notes
   * @param limit Maximum number of results to return
   * @returns Array of notes with similarity information
   */
  async findRelatedNotes(noteContext: NoteContext, limit = 5): Promise<NoteWithSimilarity[]> {
    return this.searchService.findRelatedNotes(noteContext, limit);
  }

  /**
   * Find notes that have similar tags to the profile
   * @param noteContext The NoteContext for searching notes
   * @param profileTags The profile tags to match against
   * @param limit Maximum number of results to return
   * @returns Array of notes with similarity information
   */
  async findNotesWithSimilarTags(
    noteContext: NoteContext,
    profileTags: string[],
    limit = 5,
  ): Promise<NoteWithSimilarity[]> {
    return this.searchService.findNotesWithSimilarTags(noteContext, profileTags, limit);
  }

  /**
   * Extract keywords from profile to use for searching notes
   * @param profile The profile to extract keywords from
   * @returns Array of extracted keywords
   */
  extractProfileKeywords(profile: Partial<Profile>): string[] {
    return this.tagService.extractProfileKeywords(profile);
  }

  /**
   * Prepare profile text for embedding
   * @param profile The profile data
   * @returns Formatted text for embedding generation
   */
  getProfileTextForEmbedding(profile: Partial<Profile>): string {
    return this.embeddingService.getProfileTextForEmbedding(profile);
  }
}
